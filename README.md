# Сопроводительная документация к лабораторной работе
## "Визуализация алгоритмов отсечения отрезков и многоугольников"

### Описание

Интерактивное веб-приложение для изучения и сравнения классических алгоритмов отсечения в компьютерной графике. Позволяет визуализировать процесс отсечения графических примитивов прямоугольным окном с возможностью интерактивного создания сцен и анализа результатов работы алгоритмов.

### Возможности

**Поддерживаемые алгоритмы:**

- **Алгоритм Лианга-Барски** - параметрический метод отсечения отрезков с использованием параметрического представления
- **Алгоритм Сазерленда-Ходжмана** - метод последовательного отсечения выпуклых многоугольников

**Система визуализации:**

- Координатная сетка 800×600 пикселей с подписями осей
- Интерактивное отсекающее окно с настраиваемыми параметрами
- Визуальное различие исходных и отсеченных объектов
- Режимы работы: отсечение отрезков и отсечение многоугольников

**Инструменты создания сцен:**

- Интерактивное рисование отрезков
- Создание различных типов многоугольников (треугольники, прямоугольники, пятиугольники, шестиугольники)
- Ручное построение произвольных многоугольников
- Загрузка данных из внешних файлов

### Технологии

- **Frontend**: HTML5, CSS3, JavaScript ES6+
- **Графика**: Canvas API для векторной визуализации
- **Интерфейс**: Адаптивная верстка с CSS Grid/Flexbox
- **Обработка данных**: File API для загрузки пользовательских сцен

### Реализованные алгоритмы

#### 1. Алгоритм Лианга-Барски (отсечение отрезков)

**Принцип работы:** Использует параметрическое представление отрезков для эффективного отсечения относительно прямоугольного окна.

**Математические основы:**
- Параметрическое представление отрезка: 
  ```
  x = x₁ + t⋅dx
  y = y₁ + t⋅dy
  где dx = x₂ - x₁, dy = y₂ - y₁, t ∈ [0,1]
  ```
- Для каждой границы окна вычисляются параметры входа (t₀) и выхода (t₁)

**Ключевые шаги алгоритма:**
1. Инициализация параметров: t₀ = 0, t₁ = 1
2. Для каждой границы окна (левая, правая, нижняя, верхняя):
   - Вычисление параметров p и q:
     ```
     p = [-dx, dx, -dy, dy]
     q = [x₁ - xmin, xmax - x₁, y₁ - ymin, ymax - y₁]
     ```
   - Обновление t₀ и t₁ на основе сравнения p и q
3. Если t₀ < t₁ - отрезок видим, вычисление новых координат

**Реализация:**
```javascript
function liangBarskyClip(line) {
    const {x1, y1, x2, y2} = line;
    let t0 = 0, t1 = 1;
    const dx = x2 - x1, dy = y2 - y1;
    
    const p = [-dx, dx, -dy, dy];
    const q = [x1 - xmin, xmax - x1, y1 - ymin, ymax - y1];
    
    for (let i = 0; i < 4; i++) {
        if (p[i] === 0) {
            if (q[i] < 0) return null;
        } else {
            const t = q[i] / p[i];
            if (p[i] < 0) {
                if (t > t1) return null;
                if (t > t0) t0 = t;
            } else {
                if (t < t0) return null;
                if (t < t1) t1 = t;
            }
        }
    }
    
    if (t0 < t1) {
        return {
            x1: x1 + t0 * dx,
            y1: y1 + t0 * dy,
            x2: x1 + t1 * dx,
            y2: y1 + t1 * dy
        };
    }
    return null;
}
```

**Преимущества:**
- Эффективнее алгоритма Сазерленда-Коэна
- Меньше вычислительных операций
- Особенно эффективен когда большинство отрезков полностью видимы или невидимы

**Область применения:** Современные графические системы, компьютерные игры, САПР

#### 2. Алгоритм Сазерленда-Ходжмана (отсечение многоугольников)

**Принцип работы:** Последовательно отсекает многоугольник каждой границей окна, создавая новый многоугольник после каждой итерации.

**Ключевые особенности:**
- Работает только с выпуклыми окнами отсечения
- Сохраняет структуру многоугольника
- Обрабатывает многоугольник поочередно всеми границами

**Основные шаги:**
1. Инициализация выходного списка как входного многоугольника
2. Последовательное отсечение относительно каждой границы:
   - Левая (x = xmin)
   - Правая (x = xmax) 
   - Нижняя (y = ymin)
   - Верхняя (y = ymax)
3. Для каждой границы проверка всех ребер многоугольника

**Логика обработки ребер:**
- Если обе точки внутри - добавляется вторая точка
- Если первая внутри, вторая снаружи - добавляется точка пересечения
- Если первая снаружи, вторая внутри - добавляются точка пересечения и вторая точка
- Если обе точки снаружи - ничего не добавляется

**Реализация отсечения относительно одной границы:**
```javascript
function clipAgainstEdge(inputList, edgeType) {
    if (inputList.length === 0) return [];
    
    const outputList = [];
    const n = inputList.length;
    
    for (let i = 0; i < n; i++) {
        const current = inputList[i];
        const next = inputList[(i + 1) % n];
        
        const currentInside = isInside(current, edgeType);
        const nextInside = isInside(next, edgeType);
        
        if (currentInside && nextInside) {
            outputList.push(next);
        } else if (currentInside && !nextInside) {
            const intersection = computeIntersection(current, next, edgeType);
            outputList.push(intersection);
        } else if (!currentInside && nextInside) {
            const intersection = computeIntersection(current, next, edgeType);
            outputList.push(intersection);
            outputList.push(next);
        }
    }
    return outputList;
}
```

**Функция проверки видимости точки:**
```javascript
function isInside(point, edgeType) {
    switch (edgeType) {
        case 1: return point.x >= xmin;    // Левая граница
        case 2: return point.x <= xmax;    // Правая граница  
        case 3: return point.y >= ymin;    // Нижняя граница
        case 4: return point.y <= ymax;    // Верхняя граница
        default: return false;
    }
}
```

**Вычисление точки пересечения:**
```javascript
function computeIntersection(p1, p2, edgeType) {
    let x, y;
    
    switch (edgeType) {
        case 1: // Левая граница (x = xmin)
            x = xmin;
            y = p1.y + (p2.y - p1.y) * (xmin - p1.x) / (p2.x - p1.x);
            break;
        case 2: // Правая граница (x = xmax)
            x = xmax;
            y = p1.y + (p2.y - p1.y) * (xmax - p1.x) / (p2.x - p1.x);
            break;
        case 3: // Нижняя граница (y = ymin)
            y = ymin;
            x = p1.x + (p2.x - p1.x) * (ymin - p1.y) / (p2.y - p1.y);
            break;
        case 4: // Верхняя граница (y = ymax)
            y = ymax;
            x = p1.x + (p2.x - p1.x) * (ymax - p1.y) / (p2.y - p1.y);
            break;
    }
    return { x, y };
}
```

**Преимущества:**
- Универсальность для выпуклых окон
- Сохранение структуры многоугольника
- Простота реализации и понимания

**Область применения:** Системы компьютерной графики, ГИС, обработка векторных данных

### Архитектура приложения

**Модульная структура:**

1. **Система координат и визуализации**
   - Отрисовка координатной сетки с подписями
   - Преобразование координат и масштабирование
   - Визуализация отсекающего окна и примитивов

2. **Подсистема ввода данных**
   - Интерактивное рисование отрезков и многоугольников
   - Загрузка данных из файлов формата .txt
   - Создание правильных многоугольников различных типов

3. **Реализация алгоритмов**
   - Алгоритм Лианга-Барски для отрезков
   - Алгоритм Сазерленда-Ходжмана для многоугольников
   - Вспомогательные функции для вычислений

4. **Пользовательский интерфейс**
   - Управление режимами работы
   - Настройка параметров отсекающего окна
   - Отображение статуса и результатов

**Формат входных данных:**

Для отрезков:
```
n
x1₁ y1₁ x2₁ y2₁
x1₂ y1₂ x2₂ y2₂
...
x1ₙ y1ₙ x2ₙ y2ₙ
xmin ymin xmax ymax
```

Для многоугольников:
```
n
x₁ y₁
x₂ y₂
...
xₙ yₙ
xmin ymin xmax ymax
```

### Примеры использования

**Сценарий 1: Сравнение алгоритмов отсечения**

1. Выбор режима "Отсечение отрезков"
2. Создание нескольких отрезков, пересекающих окно отсечения
3. Настройка параметров окна: Xmin=100, Ymin=100, Xmax=400, Ymax=300
4. Запуск алгоритма Лианга-Барски
5. Анализ результатов - видимые части отображаются зеленым цветом

**Сценарий 2: Работа со сложными многоугольниками**

1. Выбор режима "Отсечение многоугольника"  
2. Создание произвольного многоугольника с 6+ вершинами
3. Позиционирование многоугольника так, чтобы он частично пересекал окно
4. Применение алгоритма Сазерленда-Ходжмана
5. Наблюдение процесса последовательного отсечения границами

**Сценарий 3: Загрузка готовых сцен**

1. Подготовка файла с координатами в supported формате
2. Загрузка через интерфейс "Выберите файл"
3. Автоматическое определение типа данных (отрезки/многоугольник)
4. Визуализация и отсечение загруженных данных

### Преимущества реализации

**Технические преимущества:**
- Полностью клиентское решение без серверной зависимости
- Интуитивный интерфейс с современным дизайном
- Поддержка интерактивного создания и редактирования сцен
- Кроссплатформенная совместимость

**Образовательная ценность:**
- Наглядная демонстрация работы алгоритмов в реальном времени
- Возможность сравнения различных подходов к отсечению
- Подробные описания алгоритмов с математическим обоснованием
- Интерактивное исследование пограничных случаев

**Практическая значимость:**
- Демонстрация применения фундаментальных алгоритмов компьютерной графики
- Основы для понимания работы современных графических систем
- База для дальнейшего изучения расширенных алгоритмов отсечения

### Заключение

Разработанное веб-приложение эффективно демонстрирует работу ключевых алгоритмов отсечения в компьютерной графике, предоставляя интуитивный инструмент для их изучения и анализа. Реализация показывает практическое применение алгоритмов Лианга-Барски и Сазерленда-Ходжмана, позволяя на практике изучить их особенности, производительность и области применения.

Приложение служит качественной образовательной платформой для понимания фундаментальных принципов компьютерной графики и основ работы с графическими примитивами, обеспечивая глубокое погружение в тему алгоритмов отсечения через интерактивное экспериментирование и визуализацию.
